{"version":3,"sources":["webpack:///path---en-blog-2008-04-26-入れ子-507877a5afdfdba881b7.js","webpack:///./.cache/json/en-blog-2008-04-26-入れ子.json"],"names":["webpackJsonp","3288","module","exports","data","markdownRemark","html","frontmatter","cover","date","strDate","title","pathContext","path","langKey"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,0hDAAsgDC,aAA4CC,MAAA,KAAAC,KAAA,4BAAAC,QAAA,YAAAC,MAAA,YAAyFC,aAAgBC,KAAA,2BAAAC,QAAA","file":"path---en-blog-2008-04-26-入れ子-507877a5afdfdba881b7.js","sourcesContent":["webpackJsonp([162964488971973],{\n\n/***/ 3288:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Escape conditions</h2>\\n<p><code>// BEFORE function Func(){ hoge(); if( foo() ){ too(); many(); heavy(); function(); } }</code></p>\\n<ul>\\n<li>The method ↓ than ↑ (in the case of barrage style) can eliminate waste of processing.</li>\\n<li>Note: In the case of \\\"barrage style\\\" to the last, in the case of a compiler language etc. equipped with a true optimization mechanism, the processing speed is the same. <code>// AFTER function Func(){ hoge(); if( !foo() ){ return; } too(); many(); heavy(); function(); }</code></li>\\n</ul>\\n<h2>loop</h2>\\n<p><code>// BEFORE function Func( let hoge ){ ascent( let i in 0..100 ){ m_nFoo = hoge * 256 + i; } } // AFTER function Func( let hoge ){ let nFoo = hoge * 256; ascent( let i in 0..100 ){ m_nFoo = nFoo + i; } } // コマカシも軽量化の手段 @MainLoop(){ if( m_nCount % 2 == 0 ){ m_nAlpha = Animation( 0, 255, m_nCount, 30 ); } } @DrawLoop(){ SetAlpha( m_nAlpha ); }</code></p>\\n<p>Do not you repeat the same process over and over again?</p>\\n<h2>Use micro-thread</h2>\\n<p>The former is faster if 100 micro-threads are rotated at the same time and 100 frame functions are called at a time. (Load to process &#x3C;&#x3C; load to call function &#x3C;&#x3C; Function?</p>\\n<h2>Inline expansion</h2>\\n<ul>\\n<li>Do not inline deploy in principle. (It is almost always nothing to write the same code twice)</li>\\n<li>However, <em>this is not the case if you can expect a significant improvement in processing speed, or if the area is extremely heavy</em> . <code>// インライン展開が有効な例 __Wait( 1 ); // BAD yield; // GOOD</code></li>\\n</ul>\",\"frontmatter\":{\"cover\":null,\"date\":\"2008-04-26T00:00:06+09:00\",\"strDate\":\"2008/4/25\",\"title\":\"A nest\"}}},\"pathContext\":{\"path\":\"/en/blog/2008/04/26-入れ子/\",\"langKey\":\"en\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---en-blog-2008-04-26-入れ子-507877a5afdfdba881b7.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Escape conditions</h2>\\n<p><code>// BEFORE function Func(){ hoge(); if( foo() ){ too(); many(); heavy(); function(); } }</code></p>\\n<ul>\\n<li>The method ↓ than ↑ (in the case of barrage style) can eliminate waste of processing.</li>\\n<li>Note: In the case of \\\"barrage style\\\" to the last, in the case of a compiler language etc. equipped with a true optimization mechanism, the processing speed is the same. <code>// AFTER function Func(){ hoge(); if( !foo() ){ return; } too(); many(); heavy(); function(); }</code></li>\\n</ul>\\n<h2>loop</h2>\\n<p><code>// BEFORE function Func( let hoge ){ ascent( let i in 0..100 ){ m_nFoo = hoge * 256 + i; } } // AFTER function Func( let hoge ){ let nFoo = hoge * 256; ascent( let i in 0..100 ){ m_nFoo = nFoo + i; } } // コマカシも軽量化の手段 @MainLoop(){ if( m_nCount % 2 == 0 ){ m_nAlpha = Animation( 0, 255, m_nCount, 30 ); } } @DrawLoop(){ SetAlpha( m_nAlpha ); }</code></p>\\n<p>Do not you repeat the same process over and over again?</p>\\n<h2>Use micro-thread</h2>\\n<p>The former is faster if 100 micro-threads are rotated at the same time and 100 frame functions are called at a time. (Load to process &#x3C;&#x3C; load to call function &#x3C;&#x3C; Function?</p>\\n<h2>Inline expansion</h2>\\n<ul>\\n<li>Do not inline deploy in principle. (It is almost always nothing to write the same code twice)</li>\\n<li>However, <em>this is not the case if you can expect a significant improvement in processing speed, or if the area is extremely heavy</em> . <code>// インライン展開が有効な例 __Wait( 1 ); // BAD yield; // GOOD</code></li>\\n</ul>\",\"frontmatter\":{\"cover\":null,\"date\":\"2008-04-26T00:00:06+09:00\",\"strDate\":\"2008/4/25\",\"title\":\"A nest\"}}},\"pathContext\":{\"path\":\"/en/blog/2008/04/26-入れ子/\",\"langKey\":\"en\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/en-blog-2008-04-26-入れ子.json\n// module id = 3288\n// module chunks = 162964488971973"],"sourceRoot":""}