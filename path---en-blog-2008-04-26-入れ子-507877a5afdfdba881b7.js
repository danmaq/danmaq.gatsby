webpackJsonp([0x94372079e6c5],{3288:function(e,n){e.exports={data:{markdownRemark:{html:'<h2>Escape conditions</h2>\n<p><code>// BEFORE function Func(){ hoge(); if( foo() ){ too(); many(); heavy(); function(); } }</code></p>\n<ul>\n<li>The method ↓ than ↑ (in the case of barrage style) can eliminate waste of processing.</li>\n<li>Note: In the case of "barrage style" to the last, in the case of a compiler language etc. equipped with a true optimization mechanism, the processing speed is the same. <code>// AFTER function Func(){ hoge(); if( !foo() ){ return; } too(); many(); heavy(); function(); }</code></li>\n</ul>\n<h2>loop</h2>\n<p><code>// BEFORE function Func( let hoge ){ ascent( let i in 0..100 ){ m_nFoo = hoge * 256 + i; } } // AFTER function Func( let hoge ){ let nFoo = hoge * 256; ascent( let i in 0..100 ){ m_nFoo = nFoo + i; } } // コマカシも軽量化の手段 @MainLoop(){ if( m_nCount % 2 == 0 ){ m_nAlpha = Animation( 0, 255, m_nCount, 30 ); } } @DrawLoop(){ SetAlpha( m_nAlpha ); }</code></p>\n<p>Do not you repeat the same process over and over again?</p>\n<h2>Use micro-thread</h2>\n<p>The former is faster if 100 micro-threads are rotated at the same time and 100 frame functions are called at a time. (Load to process &#x3C;&#x3C; load to call function &#x3C;&#x3C; Function?</p>\n<h2>Inline expansion</h2>\n<ul>\n<li>Do not inline deploy in principle. (It is almost always nothing to write the same code twice)</li>\n<li>However, <em>this is not the case if you can expect a significant improvement in processing speed, or if the area is extremely heavy</em> . <code>// インライン展開が有効な例 __Wait( 1 ); // BAD yield; // GOOD</code></li>\n</ul>',frontmatter:{cover:null,date:"2008-04-26T00:00:06+09:00",strDate:"2008/4/25",title:"A nest"}}},pathContext:{path:"/en/blog/2008/04/26-入れ子/",langKey:"en"}}}});
//# sourceMappingURL=path---en-blog-2008-04-26-入れ子-507877a5afdfdba881b7.js.map