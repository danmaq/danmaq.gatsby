webpackJsonp([35104176337783],{2711:function(e,t){e.exports={data:{markdownRemark:{html:'<p>It depends on the way of weighting, but mostly you will use DirectX. If you are precisely carving the same weight, at DOS (unless you use a fairly extraordinary way) it is impossible. I tried to enumerate several methods of taking simple weights.</p>\n<h2>Sleeping by for loop</h2>\n<p>For example, this one.</p>\n<pre><code class="language-C">for(int i=0;i&#x3C;10000;i++); \n</code></pre>\n<p>It\'s easiest, but it will be useless as there will be a difference in the amount of weight between slow PC and early PC, and it can be erased entirely by compiler optimization.</p>\n<h2><code>time()</code> function</h2>\n<p>A method of constantly monitoring the time and continuing to loop indefinitely while the time does not change. Even at DOS, accurate weights can be surely made on the same time on any PC, but we can not take weights less than 1 second. (At least 1 second)</p>\n<h2><code>Sleep()</code> function</h2>\n<p>Sleep program (thread) in milliseconds using Windows timer. Although it may be ideal to be able to stop at a glance by 1 msec, this timer is not more accurate than expected, and it causes deviation of up to 50 msec., And it does not work on DOS. For the time being, it is about how much this way</p>',frontmatter:{cover:null,date:"2003-12-09T17:27:00+09:00",strDate:"2003/12/9",title:"Specific weighting method"}}},pathContext:{path:"/en/blog/2003/12/09-具体的なウェイトの捕り方/",langKey:"en"}}}});
//# sourceMappingURL=path---en-blog-2003-12-09-具体的なウェイトの捕り方-5be855bf4bfbadb45d60.js.map