webpackJsonp([0xdb328ee7453],{4180:function(n,o){n.exports={data:{markdownRemark:{html:"<h2>脱出条件</h2>\n<p><code>// BEFORE function Func(){ hoge(); if( foo() ){ too(); many(); heavy(); function(); } }</code></p>\n<ul>\n<li>↑よりも↓の手法の方が(弾幕風の場合)処理の無駄が省けます。</li>\n<li>注:あくまで“弾幕風の場合”であって、真っ当な最適化機構を備えたコンパイラ言語などの場合は処理速度は同じになります。\n<code>// AFTER function Func(){ hoge(); if( !foo() ){ return; } too(); many(); heavy(); function(); }</code></li>\n</ul>\n<h2>ループ</h2>\n<p><code>// BEFORE function Func( let hoge ){ ascent( let i in 0..100 ){ m_nFoo = hoge * 256 + i; } } // AFTER function Func( let hoge ){ let nFoo = hoge * 256; ascent( let i in 0..100 ){ m_nFoo = nFoo + i; } } // コマカシも軽量化の手段 @MainLoop(){ if( m_nCount % 2 == 0 ){ m_nAlpha = Animation( 0, 255, m_nCount, 30 ); } } @DrawLoop(){ SetAlpha( m_nAlpha ); }</code></p>\n<p>やらなくてもいい同じ処理を何度も繰り返してないか？</p>\n<h2>マイクロスレッドを使う</h2>\n<p>マイクロスレッドを100個同時に回すのと、毎フレーム関数を100個呼び出すのでは、前者の方が早い。(処理をこなす負荷＜＜関数を呼び出す負荷、なのかな？)</p>\n<h2>インライン展開</h2>\n<ul>\n<li>インライン展開は原則しないこと。(同じコードを二度書くと大抵ロクなことがない)</li>\n<li>但し、<em>それによって大幅な処理速度向上が望める場合、またその一帯が極端に重い場合はこの限りではない</em>。\n<code>// インライン展開が有効な例 __Wait( 1 ); // BAD yield; // GOOD</code></li>\n</ul>",frontmatter:{cover:null,date:"2008-04-26T00:00:06+09:00",strDate:"2008/4/25",title:"入れ子"}}},pathContext:{path:"/ja/blog/2008/04/26-入れ子/",langKey:"ja"}}}});
//# sourceMappingURL=path---ja-blog-2008-04-26-入れ子-76d095fc32c14b4b01e3.js.map